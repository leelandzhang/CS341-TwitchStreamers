---
title: "SNAP-ERGM"
author: "Murat Sankaya"
date: today
execute:
  echo: false
format: 
  pdf:
      output-file: "ergm_murat_sankaya"
      output-ext: "pdf"
      toc: true
      toc-depth: 4
      shift-heading-level-by: 2
      fig-pos: "H"
      fig-cap-location: top
      geometry:
        - top=1in
        - right=.8in
        - bottom=1in
        - left=.8in
      link-citations: true
      linkcolor: blue
      include-in-header: 
        text: |
          \usepackage{fancyhdr}
          \usepackage{titling}
          \pagestyle{fancy}
          \fancyhf{}
          \renewcommand\maketitle{
            \fancyhead[C]{
              \thetitle
              \ifx \theauthor\empty  \else \ – \theauthor \fi
              \ifx \thedate\empty  \else \ – \thedate \ \fi
            }
          }
          \fancyfoot[C]{\thepage}
---



```{r}
#| echo: false
#| output: false
#| message: false

# Exponential Random Graph Model (ERGM)

# Clear your environment
rm(list=ls())

# Install packages below if you do not have them:
# -------------------------------------------------
if (!"statnet" %in% installed.packages()) install.packages("statnet") # For fitting ERGMs
if (!"igraph" %in% installed.packages()) install.packages("igraph") # For network plotting
if (!"texreg" %in% installed.packages()) install.packages("texreg") # For printing "nicer" model output

```

# Part I: Building and Visualizing the Networks

The analysis will be using 2 types of files: "filtered_twitch_edges.csv" as the *base_network* and "filtered_twitch_features.csv" will make up the *node_attributes*. 

```{r}
#| echo: false
#| output: false
#| message: false

######################## PART I: Building and Visualizing the Networks ########################
# ----------------------------------------------------------------------------------------------------
# Dependent variable:
# “Mutual follower relationship of Twitch Users.” 

# Load the edge list and features
mutualEdgelist <- read.csv("mapped_twitch_edges2.csv")
features <- read.csv("mapped_twitch_features2.csv")

# Get all unique node IDs from features file
all_nodes <- features$numeric_id

# Create an empty network with all nodes
mutual <- network.initialize(length(all_nodes), directed = FALSE)

# Add edges
add.edges(mutual, mutualEdgelist$numeric_id_1, mutualEdgelist$numeric_id_2)

# View the summary of the network object
mutual

# Independent variables:
# Load node attributes, and store them in the mutual network object we have created
mutual |> network::set.vertex.attribute("descaled_views", 
                          value = features$views / 10000) # Attribute indicating how many views has the streamer received

mutual |> network::set.vertex.attribute("mature",features$mature) # Attribute indicating whether the streamer creates "mature" content
mutual |> network::set.vertex.attribute("life_time",features$life_time) # The time between the streamer creating the account and the last time they have uploaded content. As of 2018. 

mutual |> network::set.vertex.attribute("dead_account",features$dead_account) # Indicator variable for inactive accounts

mutual |> network::set.vertex.attribute("language",features$language) # Categorical variable for the main language used within the account

mutual |> network::set.vertex.attribute("affiliate",features$affiliate) # Indicating any affliation of user

mutual # These five variables should now be listed as vertex attributes when viewing the summary of the network
```


```{r}
# Double-check the values for all of the node variables
network::get.vertex.attribute(mutual,"descaled_views")
network::get.vertex.attribute(mutual,"mature")
network::get.vertex.attribute(mutual,"life_time")
network::get.vertex.attribute(mutual,"dead_account")
network::get.vertex.attribute(mutual,"language")
network::get.vertex.attribute(mutual,"affiliate")

```


## 1. Plotting the mutual followers network.

```{r}
# ----------------------------------------------------------------------------
# Visualize networks
# ----------------------------------------------------------------------------
library('igraph') # Ignore messages on any objects that are masked

# Set default plot options
igraph_options(vertex.size = 9, vertex.color = 'grey', # vertex.size changes the size of nodes; vertex.color changes the color of nodes
               edge.color='gray80', edge.arrow.size=.1, # edge.color changes the color of ties; edge.arrow.size changes the size of tie arrow heads
               vertex.label = NA)                       # vertex.label = NA specifies not to display vertex labels in the plot

# Plot the Advice network
mutual_igraph <- graph.adjacency(as.matrix.network(mutual)) # make an igraph network object from statnet network object
mutual_igraph <- set_vertex_attr(mutual_igraph,"language",value = features$language)
net_layout <- layout_with_fr(mutual_igraph) # Calculates and stores a spring-embedded layout
                                           # We will re-use this same layout for each plot, so nodes are always in the same place
plot(mutual_igraph, layout=net_layout, edge.color='black', vertex.label = V(mutual_igraph))

```

```{r}
# Plot the Mutual Follower Relationship Network network with node coloring based on content creator's main language

# Get the unique languages
unique_languages <- unique(features$language)

# Generate a color palette with the same length as the number of unique languages
palette <- rainbow(length(unique_languages))  # You can use other palettes like heat.colors, terrain.colors, etc.

# Create a named vector to map each language to a color
language_colors <- setNames(palette, unique_languages)

# Map the colors to each node based on their language
V(mutual_igraph)$color <- language_colors[features$language]

# Plot the network with nodes colored by language
plot(mutual_igraph, layout=net_layout, edge.color='black', vertex.label = NA)

# Add a legend to the plot
legend("topright", legend = unique_languages, col = palette, pch = 19, title = "Language")

```



# Part II: Model Estimation 

```{r}
# ----------------------------------------------------------------------------
######################## PART II: Build the ERGM model ########################
#
# R vignette for more details: https://cran.r-project.org/web/packages/ergm/ergm.pdf
# ----------------------------------------------------------------------------
detach(package:igraph) # Remove the 'igraph' package from your environment. 
library(statnet)
library(Rglpk) # This library optimizes transivity computation
options(ergm.loglik.warn_dyads=FALSE) # Whether or not a warning should be issued when sample space constraints render the observed number of dyads ill-defined
help("ergm-terms",package = "ergm")

summary(mutual ~ edges)
summary(mutual ~ nodematch("mature"))
summary(mutual ~ nodematch("affiliate"))
summary(mutual ~ nodematch("language"))
summary(mutual ~ kstar(2))
summary(mutual ~ nodecov("descaled_views"))
summary(mutual ~ nodecov("life_time"))
summary(mutual ~ gwesp(log(2), fixed = T))

```

```{r}
#| message: false

# The following commands do model estimation for ERGMs.
# This may take a second. Text will print in-console to update you on progress in model estimation.
model <- ergm(mutual ~ edges # Captures the tendency of nodes with many edges forming more mutual connections
               + nodematch("mature") # Homophily effect on the categorical variable "mature"
               + nodematch("affiliate") # Homophily effect on the categorical variable "affiliate"
               + nodematch("language") # Homophily effect on the categorical variable "language"
               + kstar(2) # Adding a 2-star term
               + nodecov("descaled_views")  # Effect of the number of descaled views on the likelihood of forming an edge         
               + nodecov("life_time") # Effect of the lifetime of an account on the likelihood of forming an edge                
               + gwesp(log(2), fixed = T)  # Adding transitivity
               , control = control.ergm(seed = 42)
               , verbose = F
)
summary(model) 

```
